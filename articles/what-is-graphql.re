= GraphQLとは何か

この章では、GraphQLとは何かと、概要について簡単に解説します。
ここで解説する内容は筆者のこれまでの経験を元にした独断と偏見を書き下したものです。
共感できるものもあるかもしれませんし、自分はもっと別の使い方をしちゃうぜ！という人もあるかもしれません。

GraphQLの概要を説明する前に、GraphQLとは何かを説明します。
おそらく、最初は読んでも何のことだかわからないかもしれません。
本書を最後まで読んでから、もう一度読み返してみてください。

GraphQLというのはフロントエンドやアプリケーションのための技術です。
近年、@<kw>{宣言的UI,Declarative UI}がだいぶ普及してきました。
WebフロントエンドであればReact@<fn>{react}、AndroidであればJetpack Compose@<fn>{jetpack-compose}、iOSであればSwift UI@<fn>{swift-ui}などです。

//footnote[react][@<href>{https://reactjs.org/}]
//footnote[jetpack-compose][@<href>{https://developer.android.com/jetpack/compose}]
//footnote[swift-ui][@<href>{https://developer.apple.com/xcode/swiftui/}]

宣言的UI、というのは雑にまとめると"こういうデータだったらUI表示はこう"という記述の集まりです。
前後の実行結果に依存しない、コンポーネント内部に個別の状態を持たない@<fn>{component-state}ステートレスなUIの作り方なのです。
これは言い換えると"源流のデータを更新するとUIに反映される"ということです。

//footnote[component-state][もつとしたら、大本のデータ更新の準備をするためのトランザクション的状態]

アプリケーションがたった1つの状態データ（single source of truth）を参照し、各コンポーネントはこれを分担してレンダリングすると考えます。
宣言的UIを実現するためのフレームワークを使っているのであれば、状態にしたがってUIをレンダリングすれば画面は表示されます。
すると、アプリケーションを作る上での問題は、グローバルに1つだけ存在する状態オブジェクトを、どうやって簡単に部分的に取得・更新するか？ということになります。

大胆に言い切ってしまえば、GraphQLはこの状態データに対して効率的にビューを作り、パッチを当てるためのシステムです。
GraphQLのキャッシュとは、状態データに他なりません。
よって、よいスキーマというのは状態データへのパッチ作業、言い換えるとキャッシュ内のデータ操作が不足なくできるものを指します。

これは、頭でわかっていても難しいことです。
APIとフロントエンドで開発者が異なる場合、API側ではフロントエンドでの便利なこと、つらいことというのには目が向きにくいものです。
また、フロントエンドの開発者も一度、不足のない素晴らしいGraphQLエンドポイントを使うまでは自分が真にほしいものを実感を伴って理解するのは難しいでしょう。
今、この本を読んでいるあなたはGraphQLスキーマを設計する機会があるのかもしれません。
その場合、使い始めてみてからフロントエンドの開発が楽になったか、定期的に振り返り反省・改善を検討するべきでしょう。

TODO 後でもうちょっとデータのパッチについて詳細に解説するパートを設けたい。

== 予備知識1：GraphQLの概要

本書ではGraphQLの仕様については詳しく解説を行いません。
しかし、ある一定の共通理解はほしいところですので、ここに簡単に解説します。

GraphQLはGraph構造のデータから任意の形のデータを取り出すためのQuery Languageです。
GraphQLスキーマはデータの型とデータ間の繋がりによって定義されます。
もちろん、静的型付けなので実行前にクエリがスキーマに対して正しいかを検証できます。
さらに、クエリからどういう構造+型のデータが得られるか分かるので、フロントエンド側でデータを正しく扱っているかを静的に検査できます。
最高ですね！
#@# OK gfx: "Graph構造のデータから" → ほんとかな！？https://graphql.org/ のトップにもgraph構造には触れてないよ！バックエンドのデータもRDBMS（表）だったりKVSだったりするよ！ただGraphQLの戻り値はツリー構造で、ツリー構造はグラフ構造の一種なので（表を扱うSQLとの比較でいうと）グラフ構造と無関係ではないものの。シンプルに説明するのは難しいね！
#@# OK vv: うーん難しいけど基本このままで。ここではバックエンドのDB実態は考慮せず、（仮想的に存在している）グラフ構造のデータ（≒スキーマ）から任意の形のデータが取り出せる ということなので説明としては間違ってない！

SQLとGraphQLはDBへのクエリとサーバAPIへのクエリという点でだいぶ隔たりがありますが、比較してみます（@<img>{sql-graphql}）。

//image[sql-graphql][SQLとGraphQLで得られるデータ構造の比較]{
//}

SQLは@<kw>{RDB,Relational Database}に対してデータを要求する時に使います。
結果は基本的に表形式、つまり2次元のデータとして得られます。

一方GraphQLはサーバAPIに対してデータを要求する時に使います。
結果はツリー構造で得られます。

得られる形式に注目した場合、データを使った計算処理やバッチ処理を行うには2次元のデータのほうが都合がよく、画面で利用するにはツリー構造のほうが都合がよいでしょう。

なぜそういう違いになるかというと、データの結合に対する考え方が異なるのです。
RDBではテーブルに外部キーとなるカラムを持ち、クエリでもって何をどう結合するかを決定します。

対してGraphQLではスキーマの段階でどの型（RDBでいうテーブル）がどの型に広がっていくか（関連しているか）を定義します。
GraphQLでのクエリはそのスキーマに対して"こういうレイアウトでデータをおくれ"と頼むだけで、結合の仕方を変更する能力はありません。

スキーマで行える関係性の定義は柔軟です。
たとえば@<code>{User}型に@<code>{friends(first: Int, after: String): [User!]}というフィールドがあるとします。
すると、クエリでは"User"の"friends"の"friends"をくれ！という具合に定義された関係性を好きな深さまで辿っていくことができます@<fn>{not-infinit}。

//footnote[not-infinit][もちろん現実的にはDBの負荷や計算量やレスポンスにかかる時間を考えどこかで制限をかける必要があります。RDBと同じ。]

クライアントからクエリを投げられるということは、SQLのように発行者が常に信用できるとは限らないため、セキュリティについて考える必要があります。
事前に危険なクエリではないかチェック可能にするため、スキーマ設計の段階で気をつけるべきポイントがあります。

== 予備知識2：どうやってGraphQLサーバは動作するのか

GraphQLサーバはresolverによってクエリをレスポンスに変換します。
どんな形のクエリでも一発で目的のレスポンスに解決（resolve）できるresolverを想像すると、とんでもなく複雑です。
普通に考えて、どういう設計にすればいいのかすら検討がつかないでしょう。

しかし、@<code>{UserID}を@<code>{User}に変換するresolverであれば実装は容易です。
DBの@<code>{User}テーブルから@<code>{friendIDs}を取得することはできそうです。
そして、そこからさらに@<code>{UserID}を@<code>{User}に変換するresolverを利用し@<code>{User}のリストにすることもできそうです。
このように、スキーマのパーツからパーツへの変換を行う無数のresolverを作成し、それを合体させたものが、当初欲しかった複雑なクエリのresolverとなるのです。
あとは、実際のクエリにあわせて必要なresolver@<strong>{のみ}をチョイスし動作させて結果を得ます。

ものすごく無駄かつ豪華な実装では、GraphQLスキーマのすべてのフィールドに対して1つの1つresolverを作ることも可能です。
@<code>{User.id}、@<code>{User.name}、@<code>{User.email}、個別に丹念にresolverを実装するとしたら…？
1つのテーブルから一発で取得できるようなフィールドに、個別にresolverを実装したらストレスで胃に穴が3個は開くでしょう。

なので、1つの型に対して最低1つのresolverを作るのが一般的です。
もちろん@<code>{User.cpuHeavyField}のような、本来DB上に存在しないものには個別にresolverの実装を与える必要があります。
よくあるパターンとしては@<code>{User.groupID}のような別データのIDをもつ場合、@<code>{User.group}を作り出すために@<code>{GroupID}から@<code>{Group}に変換するresolverが必要になります。

GraphQLのスキーマとDB上のデータをつなぎ合わせるためには、resolverをどう実装するかが重要です。
